#include<iostream>
#include<string>
using namespace std;



/*
	指针
		What?
			指针本身也是一个数据对象

			用来存放其他某个数据对象的内存地址 - 间接访问
*/
int main() {
	// 定义指针 🧭
	int* p1; //用【指针】定义某个数据类型, 可以不做初始化
	long* p2; //用【指针】定义某个数据类型, 可以不做初始化
	float* p3; // 指向的数据是 float 的数据类型
	void* p4; //【🔥特殊🔥】表示可以指向任意类型的数据对象

	cout << p1 << " " << p2 << " " << p3 << endl;
	cout << sizeof(p1) << " " << sizeof(p2) << " " << sizeof(p3) << endl; // 8 -> 因为指向的对象是 64 位系统, 用 8 个字节来存放数据的。  指针的大小跟系统的内存地址空间有关系, 跟指向的数据对象没关系, 因为这个系统是 64 位系统, 所以是 8 字节


	int a = 10;
	int b = 20;
	long c = 35;

	// 地址操作符 & 🌍, 可以捕捉另外一个对象的地址, 相当于给指针赋值
	p1 = &a; //【指针初始化】 =>  把 a 的地址拿出来赋值给 【p1 指针】, 🔥注意类型得对应！！！ int 指针对应 int 变量的地址
	p2 = &c; //【指针初始化】 =>  把 c 的地址拿出来赋值给 【p2 指针】, 🔥注意类型得对应！！！ int 指针对应 int 变量的地址
	

	cout << "变量 a 的地址为: " << &a << endl;
	cout << "变量 b 的地址为: " << &b << endl;
	cout << p2 << endl; // 0x16b6c6828 => 0x16b6c6828


	// 访问指针所保存的数据(解引用, *XX ) 🌟
	*p1 = 12; // 相当于改了 a, 操作 p1 就是操作了 a 🚀
	cout << "a 的新值: " << a << endl;

	p1 = &b; // 也可以重新捕捉 p1 的地址, 从指向 a 换成指向 b
	*p1 = 998;
	cout << "此时 p1 就是 b 的值" << b << endl; // 998
	cout << "此时 a 还是: " << a << endl; // 12



	// 【野指针 => 没初始化】如果定义指针后, 指针没有指向任何对象, 然后直接解引用来访问指针, 那么就会很危险, 因为可能会随机指向一个内存地址 （可能会指向到系统的内存地址）

	// 【空指针 => 定义时, 指向一个没有任何含义的地址】
	int* np = NULL;  // 预处理变量
	int* np2 = nullptr; // 空指针字面值
	int* np3 = 0; // 0 也可以表示空指针

}