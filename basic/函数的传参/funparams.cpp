#include<iostream>
using namespace std;



/*
	函数的参数, 🚀 跟 js 不一样!! C++ 都是【🔥拷贝一份再赋值】, 而不是默认为引用！
		1.传值参数（拷贝初始化）
		2.引用参数
*/ 


// Case: 传入 x, 然后 x 递增 1



// 方法1.传值参数（拷贝初始化）————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
void inCrease(int* x) { //👈👈指针类型的参数, 这样每次 ++x 后就会改变原来的值
	++(*x); //🔥🔥🔥解引用, 让 x 指向 👇 n 的地址！！这样就可以改变 n 的值了, 不然每次 n 都会初始化为 0
};



// 方法2.传入引用参数 ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
void inCrease2(int& x) {
	++x;
};



// Case: 比较两个字符串的长度
bool isLongger(const string & str1, const string& str2) {// 🔥因为不改变传入的参数, 所以可以定义为常量引用
	return str1.length() > str2.length(); // 拷贝传参的话效率不高, 更好的事引用别名
}




/* 
	可变形参:
		方法 1: 省略号 （只能出现在最后一个参数）
		方法 2: 初始化列表
		方法 3: 可变参数模板
*/





int main() {

	// 方法1.传值参数（拷贝初始化）——————————
	int n = 0; //拷贝传值的话, 不会改变这个【🔥实参】！除非传入的是【🔥实参的地址！】
	inCrease(&n); // &n 表示传入 n 的内存地址, 本质上是 int* x = &n
	inCrease(&n); // &n 表示传入 n 的内存地址, 本质上是 int* x = &n
	cout << "n = " << n << endl;


	// 方法2.传入引用参数 ————————————————
	int m = 0; 
	inCrease2(m); // 传入 n 的引用, 这样就可以改变 m 的值了, 本质上是🔥  int& x = m   =>   对 x 的操作都是对 m 的操作
	inCrease2(m);
	cout << "m = " << m << endl;



	// Case: 比较字符串的长度
	string str1 = "hello abc", str2 = "hey";
	cout << isLongger(str1, str2) << endl; //1 => true
	cout << isLongger("hello", "hey") << endl; //1 => true

	cin.get();
}